<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CiFEr: CiFEr - Functional Encryption library [![Build Status](https://circleci.com/gh/fentec-project/CiFEr.svg?style=svg)](https://circleci.com/gh/fentec-project/CiFEr)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CiFEr
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">CiFEr - Functional Encryption library [![Build Status](<a href="https://circleci.com/gh/fentec-project/CiFEr.svg?style=svg">https://circleci.com/gh/fentec-project/CiFEr.svg?style=svg</a>)](<a href="https://circleci.com/gh/fentec-project/CiFEr">https://circleci.com/gh/fentec-project/CiFEr</a>) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>CiFEr (prounounced as <em>cipher</em>) is a cryptographic library offering different state-of-the-art implementations of functional encryption schemes, specifically FE schemes for <em>linear</em> polynomials (e.g. <em>inner products</em>). It is implemented in C. A <a href="https://github.com/fentec-project/gofe">Go version named GoFE</a> of the library also exists.</p>
<p>To quickly get familiar with FE, read a short and very high-level introduction on our <a href="https://github.com/fentec-project/gofe/wiki/Introduction-to-FE">Introductory Wiki page</a>.</p>
<p>The documentation for CiFEr is available on <a href="https://fentec-project.github.io/CiFEr">GitHub Pages</a>.</p>
<p>CiFEr is distributed under the <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache 2 license</a>. It uses <a href="https://gmplib.org/">GMP</a>, which is distributed under the dual licenses, <a href="https://www.gnu.org/licenses/lgpl.html">GNU LGPL v3</a> and <a href="https://www.gnu.org/licenses/gpl-2.0.html">GNU GPL v2</a>.</p>
<ul>
<li><a href="#building-cifer">Building CiFEr</a><ul>
<li><a href="#requirements">Requirements</a></li>
<li><a href="#build-and-install">Build and install</a></li>
<li><a href="#test">Test</a></li>
</ul>
</li>
<li><a href="#using-cifer-in-your-project">Using CiFEr in your project</a><ul>
<li><a href="#select-the-fe-scheme">Select the FE scheme</a></li>
<li><a href="#configure-selected-scheme">Configure selected scheme</a></li>
<li><a href="#prepare-input-data">Prepare input data</a></li>
<li><a href="#use-the-scheme-(examples)">Use the scheme (examples)</a></li>
</ul>
</li>
</ul>
<h3>Before using the library</h3>
<p>Please note that the library is a work in progress and has not yet reached a stable release. Code organization and APIs are <b>not stable</b>. You can expect them to change at any point.</p>
<p>The purpose of CiFEr is to support research and proof-of-concept implementations. It <b>should not be used in production</b>.</p>
<h2>Building CiFEr</h2>
<h3>Requirements</h3>
<p>The requirements have to be installed manually (via package manager or building the source code).</p><ul>
<li><a href="https://cmake.org/download/">CMake</a> (version 3.11+)</li>
<li><a href="https://gmplib.org/">GMP</a></li>
<li><a href="https://download.libsodium.org/doc/">libsodium</a></li>
<li><a href="https://github.com/miracl/amcl">AMCL</a></li>
</ul>
<p>CiFEr relies on GMP for all big integer arithmetic. We recommend familiarizing yourself with it before using CiFEr.</p>
<p>To be able to build CiFEr as described below, AMCL must be compiled with BN254 curve. This can be done manually, but for convenience, we provide a Bash script that runs a modified AMCL setup (a Python script) and installs a minimal version of AMCL in the standard directory <code>/usr/local/lib</code> and header files in <code>/usr/local/include</code>. These default values can be changed in <code>external/amcl/setup_amcl.sh</code>. To use the script, run: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cd external/amcl</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;sudo ./setup_amcl.sh</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;cd ../..</div></div><!-- fragment --><h3>Build and install</h3>
<p>To build and install, first download it, then run the following commands in the source code directory: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;mkdir build</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cd build</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;cmake ..</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;make</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;sudo make install</div></div><!-- fragment --><p> This builds the shared library (<code>libcifer.so</code>) and installs it. By default, it places the shared library in <code>/usr/local/lib</code> and the header files in <code>/usr/local/include</code> (For this, you will need to run the command as superuser). To set a custom install directory (e.g. an <code>install</code> directory in the root of the repo) instead of <code>/usr/local</code>, pass it to the cmake command, e.g.: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cmake .. -DCMAKE_INSTALL_PREFIX=../install</div></div><!-- fragment --><h3>Test</h3>
<p>The build commands also create an executable which runs all unit tests. To make sure the library works as expected, run </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;make test</div></div><!-- fragment --><p> Note that this command also builds the library and test executable if they have not been built yet.</p>
<h2>Using CiFEr in your project</h2>
<p>After you have successfuly built and installed the library, you can use it in your project. Instructions below provide a brief introduction to the most important parts of the library, and guide you through a sequence of steps that will quickly get your FE example up and running.</p>
<h3>Including and linking</h3>
<p>To use the library, you must <code>#include</code> its headers in your source code and link it with the <code>-lcifer</code> flag when building your code.</p>
<h3>Select the FE scheme</h3>
<p>You can choose from the following set of schemes:</p>
<h4>Inner product schemes</h4>
<p>You will need to include headers from <code>innerprod</code> directory.</p>
<p>We organized implementations in two categories based on their security assumptions:</p>
<ul>
<li>Schemes with <b>selective security under chosen-plaintext attacks</b> (s-IND-CPA security):<ul>
<li>Scheme by <em>Abdalla et. al.</em> (<a href="https://eprint.iacr.org/2015/017.pdf">paper</a>). The scheme can be instantiated from DDH (<code><a class="el" href="structcfe__ddh.html">cfe_ddh</a></code>), LWE (<code><a class="el" href="structcfe__lwe.html">cfe_lwe</a></code>) and RingLWE (<code><a class="el" href="structcfe__ring__lwe.html">cfe_ring_lwe</a></code>) primitives.</li>
<li>Multi-input scheme based on paper by <em>Abdalla et.al</em> (<a href="https://eprint.iacr.org/2017/972.pdf">paper</a>) and instantiated from the scheme in the first point (<code><a class="el" href="structcfe__ddh__multi.html">cfe_ddh_multi</a></code>).</li>
</ul>
</li>
<li>Schemes with <b>adaptive security under chosen-plaintext attacks</b> (IND-CPA security) by<ul>
<li>Scheme based on paper by <em>Agrawal, Libert and Stehlé</em> (<a href="https://eprint.iacr.org/2015/608.pdf">paper</a>). It can be instantiated from Damgard DDH (<code><a class="el" href="structcfe__damgard.html">cfe_damgard</a></code> - similar to <code><a class="el" href="structcfe__ddh.html">cfe_ddh</a></code>, but uses one more group element to achieve full security, similar to how Damgård's encryption scheme is obtained from ElGamal scheme (<a href="https://link.springer.com/chapter/10.1007/3-540-46766-1_36">paper</a>)), LWE (<code><a class="el" href="structcfe__lwe__fs.html">cfe_lwe_fs</a></code>) and Paillier (<code><a class="el" href="structcfe__paillier.html">cfe_paillier</a></code>) primitives.</li>
<li>Multi-input scheme based on paper by <em>Abdalla et.al</em> (<a href="https://eprint.iacr.org/2017/972.pdf">paper</a>) and instantiated from the scheme in the first point (<code><a class="el" href="structcfe__damgard__multi.html">cfe_damgard_multi</a></code>).</li>
</ul>
</li>
</ul>
<h4>Attribute based encryption (ABE) schemes</h4>
<p>You will need to include headers from <code>abe</code> directory. There are two implemented schemes:</p><ul>
<li>A ciphertext policy (CP) ABE scheme named FAME by <em>Agrawal and Chase</em> (<a href="https://eprint.iacr.org/2017/807.pdf">paper</a>) allowing encrypting a message based on a boolean expression defining a policy which attributes are needed for the decryption. The functions needed in this scheme have prefix <code><a class="el" href="structcfe__fame.html">cfe_fame</a></code>.</li>
<li>A key policy (KP) ABE scheme by <em>Goyal, Pandey, Sahai, and Waters</em> (<a href="https://eprint.iacr.org/2006/309.pdf">paper</a>) allowing a distribution of keys following a boolean expression defining a policy which attributes are needed for the decryption. The functions needed in this scheme have prefix <code><a class="el" href="structcfe__gpsw.html">cfe_gpsw</a></code>.</li>
</ul>
<p>These schemes allow to specify a decryption policy defining which attributes are needed to be able to decrypt. For the latter we implemented a policy converter which accepts a boolean expression defining the policy and outputs a monotone span program (MSP) which can be used as an input for the ABE schemes.</p>
<h3>Configure selected scheme</h3>
<p>All CiFEr schemes are implemented as C structs + functions which operate on them with (at least logically) similar APIs. So the first thing we need to do is to create a scheme instance by initializing the appropriate struct. For this step, we need to pass in some configuration, e.g. values of parameters for the selected scheme.</p>
<p>Let's say we selected a <code><a class="el" href="structcfe__ddh.html">cfe_ddh</a></code> scheme. We create a new scheme instance with: </p><div class="fragment"><div class="line">mpz_t bound;</div><div class="line">mpz_init_set_ui(bound, 2 &lt;&lt; 14);</div><div class="line"><a class="code" href="structcfe__ddh.html">cfe_ddh</a> s;</div><div class="line"><a class="code" href="ddh_8h.html#a6a0a1e8804d803cdbc147fbed029c7e3">cfe_ddh_init</a>(&amp;s, 3, 128, bound);</div></div><!-- fragment --><p>In the last line above, the first argument is length of input vectors <b>x</b> and <b>y</b>, the second argument is bit length of prime modulus <em>p</em> (because this particular scheme operates in the &amp;#8484;<sub>p</sub> group), and the last argument represents the upper bound for elements of input vectors.</p>
<p>However, configuration parameters for different FE schemes vary quite a bit. Please refer to <a href="https://fentec-project.github.io/CiFEr">library documentation</a> regarding the meaning of parameters for specific schemes. For now, examples and reasonable defaults can be found in the test code.</p>
<p>After you successfully created a FE scheme instance, you can call the relevant functions for:</p><ul>
<li>generation of (secret and public) master keys,</li>
<li>derivation of functional encryption key,</li>
<li>encryption, and</li>
<li>decryption.</li>
</ul>
<h3>Prepare input data</h3>
<h4>Vectors and matrices</h4>
<p>All CiFEr chemes rely on vectors (or matrices) of big integer (<code>mpz_t</code>) components.</p>
<p>CiFEr schemes use the library's own vector (<code><a class="el" href="structcfe__vec.html">cfe_vec</a></code>) and matrix (<code><a class="el" href="structcfe__mat.html">cfe_mat</a></code>) types. They are available in the <code>data</code> directory. A <code><a class="el" href="structcfe__vec.html">cfe_vec</a></code> is basically a wrapper around an array of <code>mpz_t</code> integers, while a <code><a class="el" href="structcfe__mat.html">cfe_mat</a></code> is a wrapper around an array of <code><a class="el" href="structcfe__vec.html">cfe_vec</a></code> vectors.</p>
<p>In general, you only have to worry about providing input data (usually vectors <b>x</b> and <b>y</b>). Each element in a vector or matrix can be set by calling their respective <code>_set</code> function, for example: </p><div class="fragment"><div class="line"><a class="code" href="structcfe__vec.html">cfe_vec</a> x, y;</div><div class="line"><a class="code" href="vec_8h.html#a8d1fa0b403a0433034453a3b0b7eae0f">cfe_vec_init</a>(&amp;x, 3);</div><div class="line"><a class="code" href="vec_8h.html#a8d1fa0b403a0433034453a3b0b7eae0f">cfe_vec_init</a>(&amp;y, 3);</div><div class="line">mpz_t el;</div><div class="line">mpz_init(el);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 3; i++) {</div><div class="line">    mpz_set_ui(el, i+1);</div><div class="line">    <a class="code" href="vec_8h.html#a4c47b49480b821dee53e3f111f5628a2">cfe_vec_set</a>(&amp;x, el, i);</div><div class="line">    <a class="code" href="vec_8h.html#a4c47b49480b821dee53e3f111f5628a2">cfe_vec_set</a>(&amp;y, el, 2-i);</div><div class="line">}</div><div class="line"><span class="comment">// x is [1, 2, 3], y is [3, 2, 1]</span></div></div><!-- fragment --><p>For matrices, you can set whole rows to contain the same values as a vector. </p><div class="fragment"><div class="line"><a class="code" href="structcfe__mat.html">cfe_mat</a> A;</div><div class="line"><a class="code" href="mat_8h.html#ab4288d110d902bd7c0f4fd72e36cb35e">cfe_mat_init</a>(&amp;A, 2, 3);</div><div class="line"><a class="code" href="mat_8h.html#a625c8025ba8b0863914bd4da4dd99355">cfe_mat_set_vec</a>(&amp;A, &amp;x, 0);</div><div class="line"><a class="code" href="mat_8h.html#a625c8025ba8b0863914bd4da4dd99355">cfe_mat_set_vec</a>(&amp;A, &amp;y, 1);</div><div class="line"><span class="comment">// A is [[1, 2, 3], [3, 2, 1]]</span></div></div><!-- fragment --><h4>Random data</h4>
<p>To generate random <code>mpz_t</code> values from different probability distributions, you can use one of our several implementations of random samplers. The samplers are provided in the <code>sample</code> directory. Note that the uniform sampler does not require special initialization while other samplers do. Before performing any random sampling, the function <code>cfe_init</code> needs to be called to ensure that the system's random number generator has been properly seeded.</p>
<p>You can quickly construct random vectors and matrices by:</p><ol type="1">
<li>Configuring the sampler of your choice, for example: ```c <a class="el" href="common_8h.html#a5f0f38a6cc7347a85261a841e8032e10">cfe_init()</a>; mpf_t sigma; mpf_init_set_ui(sigma, 10); <a class="el" href="structcfe__normal__cumulative.html">cfe_normal_cumulative</a> s; // samples the cumulative normal (Gaussian) probability distribution, centered on 0 cfe_normal_cumulative_init(&amp;s, sigma, 256, true); ```</li>
<li><p class="startli">Providing the data structure and sampler as an argument to the relevant <code>_sample_vec</code> or <code>_sample_mat</code> functions. ```c <a class="el" href="structcfe__vec.html">cfe_vec</a> v; <a class="el" href="structcfe__mat.html">cfe_mat</a> m; cfe_vec_init(&amp;v, 5); cfe_mat_init(&amp;m, 2, 3); cfe_normal_cumulative_sample_vec(&amp;v, &amp;s); // sets all elements of the vector to random elements cfe_normal_cumulative_sample_mat(&amp;m, &amp;s); // sets all elements of the matrix to random elements</p>
<p class="startli">// Uniform sampler (does not need to be initialized) mpz_t max; mpz_init_set_ui(max, 10); cfe_uniform_sample_vec(&amp;v, max); ```</p>
</li>
</ol>
<h2>Use the scheme (examples)</h2>
<p>Please note that all the examples below omit error handling. All functions which can fail return a <code>cfe_error</code> (its definition is in <code><a class="el" href="errors_8h.html" title="Error definitions. ">errors.h</a></code> header, located in the <code>internal</code> directory) which is non-zero if the function encountered an error.</p>
<p>Additionally, all examples also omit memory freeing. In CiFEr, all functions which allocate memory for their results (passed as input parameters) have the suffix <code>_init</code> and have a corresponding function with the suffix <code>_free</code>. All other functions expect their inputs to be already initialized and do not allocate any memory the user would need to free manually.</p>
<h5>Using a single input scheme</h5>
<p>The example below demonstrates how to use single input scheme instances. Although the example shows how to use the <code><a class="el" href="structcfe__ddh.html">cfe_ddh</a></code> scheme from directory <code>simple</code>, the usage is similar for all single input schemes, regardless of their security properties (s-IND-CPA or IND-CPA) and instantiation (DDH or LWE).</p>
<p>You will see that three <code><a class="el" href="structcfe__ddh.html">cfe_ddh</a></code> structs are instantiated to simulate the real-world scenarios where each of the three entities involved in FE are on separate machines.</p>
<div class="fragment"><div class="line"><span class="comment">// Instantiation of a trusted entity that</span></div><div class="line"><span class="comment">// will generate master keys and FE key</span></div><div class="line"><span class="keywordtype">size_t</span> l = 2; <span class="comment">// length of input vectors</span></div><div class="line">mpz_t bound, fe_key, xy, el;</div><div class="line">mpz_inits(bound, fe_key, xy, el, NULL);</div><div class="line">mpz_set_ui(bound, 10); <span class="comment">// upper bound for input vector coordinates</span></div><div class="line">modulus_len := 128 <span class="comment">// bit length of prime modulus p</span></div><div class="line"></div><div class="line"><a class="code" href="structcfe__ddh.html">cfe_ddh</a> s, encryptor, decryptor;</div><div class="line"><a class="code" href="ddh_8h.html#a6a0a1e8804d803cdbc147fbed029c7e3">cfe_ddh_init</a>(&amp;s, l, modulus_len, bound);</div><div class="line"><a class="code" href="structcfe__vec.html">cfe_vec</a> msk, mpk, ciphertext, x, y;</div><div class="line"><a class="code" href="ddh_8h.html#a3aaf947e536311a34d48397c347e9bfb">cfe_ddh_master_keys_init</a>(&amp;msk, &amp;mpk, &amp;s);</div><div class="line"><a class="code" href="ddh_8h.html#a5205c90990e16d4d54d4f976fa1d36a5">cfe_ddh_generate_master_keys</a>(&amp;msk, &amp;mpk, &amp;s);</div><div class="line"></div><div class="line"><a class="code" href="vec_8h.html#a8d1fa0b403a0433034453a3b0b7eae0f">cfe_vec_init</a>(&amp;y, 2);</div><div class="line">mpz_set_ui(el, 1);</div><div class="line"><a class="code" href="vec_8h.html#a4c47b49480b821dee53e3f111f5628a2">cfe_vec_set</a>(&amp;y, el, 0);</div><div class="line">mpz_set_ui(el, 2);</div><div class="line"><a class="code" href="vec_8h.html#a4c47b49480b821dee53e3f111f5628a2">cfe_vec_set</a>(&amp;y, el, 1); <span class="comment">// y is [1, 2]</span></div><div class="line"></div><div class="line"><a class="code" href="ddh_8h.html#ac95cc56367226ab517044125f06d3c17">cfe_ddh_derive_key</a>(fe_key, &amp;s, &amp;msk, &amp;y);</div><div class="line"></div><div class="line"><span class="comment">// Simulate instantiation of encryptor </span></div><div class="line"><span class="comment">// Encryptor wants to hide x and should be given</span></div><div class="line"><span class="comment">// master public key by the trusted entity</span></div><div class="line"><a class="code" href="vec_8h.html#a8d1fa0b403a0433034453a3b0b7eae0f">cfe_vec_init</a>(&amp;x, 2);</div><div class="line">mpz_set_ui(el, 3);</div><div class="line"><a class="code" href="vec_8h.html#a4c47b49480b821dee53e3f111f5628a2">cfe_vec_set</a>(&amp;x, el, 0);</div><div class="line">mpz_set_ui(el, 4);</div><div class="line"><a class="code" href="vec_8h.html#a4c47b49480b821dee53e3f111f5628a2">cfe_vec_set</a>(&amp;x, el, 1); <span class="comment">// x is [3, 4]</span></div><div class="line"></div><div class="line"><a class="code" href="ddh_8h.html#a9ac50b2a63c87eb0fcb422b515cbc6e3">cfe_ddh_copy</a>(&amp;encryptor, &amp;s);</div><div class="line"><a class="code" href="ddh_8h.html#a4de4e696bbb7bccb838a7a2bc617e21b">cfe_ddh_ciphertext_init</a>(&amp;ciphertext, &amp;encryptor);</div><div class="line"><a class="code" href="ddh_8h.html#aecb52e48dbb360759d440639ed3696eb">cfe_ddh_encrypt</a>(&amp;ciphertext, &amp;encryptor, &amp;x, &amp;mpk);</div><div class="line"></div><div class="line"><span class="comment">// Simulate instantiation of decryptor that decrypts the cipher </span></div><div class="line"><span class="comment">// generated by encryptor.</span></div><div class="line"><a class="code" href="ddh_8h.html#a9ac50b2a63c87eb0fcb422b515cbc6e3">cfe_ddh_copy</a>(&amp;decryptor, &amp;s);</div><div class="line"><span class="comment">// decrypt to obtain the result: inner prod of x and y</span></div><div class="line"><span class="comment">// we expect xy to be 11 (e.g. &lt;[1,2],[3,4]&gt;)</span></div><div class="line"><a class="code" href="ddh_8h.html#a0ab09755332ddbb7bf46f0689851d58b">cfe_ddh_decrypt</a>(xy, &amp;decryptor, &amp;ciphertext, fe_key, &amp;y);</div></div><!-- fragment --><h5>Using a multi input scheme</h5>
<p>This example demonstrates how multi input FE schemes can be used.</p>
<p>Here we assume that there are <code>slots</code> encryptors (e<sub>i</sub>), each with their corresponding input vector x<sub>i</sub>. A trusted entity generates all the master keys needed for encryption and distributes appropriate keys to appropriate encryptor. Then, encryptor e<sub>i</sub> uses their keys to encrypt their data x<sub>i</sub>. The decryptor collects ciphers from all the encryptors. It then relies on the trusted entity to derive a decryption key based on its own set of vectors y<sub>i</sub>. With the derived key, the decryptor is able to compute the result - inner product over all vectors, as <em>Σ &lt;x<sub>i</sub>,y<sub>i</sub>&gt;.</em></p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> slots = 2;             <span class="comment">// number of encryptors</span></div><div class="line"><span class="keywordtype">size_t</span> l = 3;                 <span class="comment">// length of input vectors</span></div><div class="line">mpz_t bound, prod;</div><div class="line">mpz_init_set_ui(bound, 1000); <span class="comment">// upper bound for input vectors</span></div><div class="line"></div><div class="line"><span class="comment">// Simulate collection of input data.</span></div><div class="line"><span class="comment">// X and Y represent matrices of input vectors, where X are collected</span></div><div class="line"><span class="comment">// from slots encryptors (ommitted), and Y is only known by a single decryptor.</span></div><div class="line"><span class="comment">// Encryptor i only knows its own input vector X[i].</span></div><div class="line"><a class="code" href="structcfe__mat.html">cfe_mat</a> X, Y;</div><div class="line"><a class="code" href="mat_8h.html#a7f5df26bc6065241a4df21f8b63ad023">cfe_mat_inits</a>(slots, l, &amp;X, &amp;Y, NULL);</div><div class="line"><a class="code" href="uniform_8h.html#a2e2c6bbe0726b704c6f7a08de4fd921c">cfe_uniform_sample_mat</a>(&amp;X, bound);</div><div class="line"><a class="code" href="uniform_8h.html#a2e2c6bbe0726b704c6f7a08de4fd921c">cfe_uniform_sample_mat</a>(&amp;Y, bound);</div><div class="line"></div><div class="line"><span class="comment">// Trusted entity instantiates scheme instance and generates</span></div><div class="line"><span class="comment">// master keys for all the encryptors. It also derives the FE</span></div><div class="line"><span class="comment">// key derivedKey for the decryptor.</span></div><div class="line"><span class="keywordtype">size_t</span> modulus_len = 64;</div><div class="line"><a class="code" href="structcfe__ddh__multi.html">cfe_ddh_multi</a> m, decryptor;</div><div class="line"><a class="code" href="ddh__multi_8h.html#a0fb58aa836d1356684c27ccccac1463c">cfe_ddh_multi_init</a>(&amp;m, slots, l, modulus_len, bound);</div><div class="line"></div><div class="line"><a class="code" href="structcfe__mat.html">cfe_mat</a> mpk;</div><div class="line"><a class="code" href="structcfe__ddh__multi__sec__key.html">cfe_ddh_multi_sec_key</a> msk;</div><div class="line"><a class="code" href="ddh__multi_8h.html#a373beee1b1b98f982cdc7a185bfffd41">cfe_ddh_multi_master_keys_init</a>(&amp;mpk, &amp;msk, &amp;m);</div><div class="line"><a class="code" href="ddh__multi_8h.html#aa118b19bd160ce58ba1a8ca0c47a0a75">cfe_ddh_multi_generate_master_keys</a>(&amp;mpk, &amp;msk, &amp;m);</div><div class="line"><a class="code" href="structcfe__ddh__multi__fe__key.html">cfe_ddh_multi_fe_key</a> fe_key;</div><div class="line"><a class="code" href="ddh__multi_8h.html#a2ba6963953cb73d7a135e0a0323ec6e6">cfe_ddh_multi_fe_key_init</a>(&amp;fe_key, &amp;m);</div><div class="line"><a class="code" href="ddh__multi_8h.html#a897c66fec6fa185996b01ad637773234">cfe_ddh_multi_derive_key</a>(&amp;fe_key, &amp;m, &amp;msk, &amp;Y);</div><div class="line"></div><div class="line"><span class="comment">// Different encryptors may reside on different machines.</span></div><div class="line"><span class="comment">// We simulate this with the for loop below, where slots</span></div><div class="line"><span class="comment">// encryptors are generated.</span></div><div class="line"><a class="code" href="structcfe__ddh__multi__enc.html">cfe_ddh_multi_enc</a> encryptors[slots];</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; slots; i++) {</div><div class="line">    <a class="code" href="ddh__multi_8h.html#a69dab47aa023d11e414e3235dff05732">cfe_ddh_multi_enc_init</a>(&amp;encryptors[i], &amp;m);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Each encryptor encrypts its own input vector X[i] with the</span></div><div class="line"><span class="comment">// keys given to it by the trusted entity.</span></div><div class="line"><a class="code" href="structcfe__mat.html">cfe_mat</a> ciphertext;</div><div class="line"><a class="code" href="mat_8h.html#ab4288d110d902bd7c0f4fd72e36cb35e">cfe_mat_init</a>(&amp;ciphertext, slots, l + 1);</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; slots; i++) {</div><div class="line">    <a class="code" href="structcfe__vec.html">cfe_vec</a> ct;</div><div class="line">    <a class="code" href="structcfe__vec.html">cfe_vec</a> *pub_key = <a class="code" href="mat_8h.html#a488ec9f10ceb2f8d24a2abc00f974357">cfe_mat_get_row_ptr</a>(&amp;mpk, i);</div><div class="line">    <a class="code" href="structcfe__vec.html">cfe_vec</a> *otp = <a class="code" href="mat_8h.html#a488ec9f10ceb2f8d24a2abc00f974357">cfe_mat_get_row_ptr</a>(&amp;msk.otp_key, i);</div><div class="line">    <a class="code" href="structcfe__vec.html">cfe_vec</a> *x_vec = <a class="code" href="mat_8h.html#a488ec9f10ceb2f8d24a2abc00f974357">cfe_mat_get_row_ptr</a>(&amp;X, i);</div><div class="line">    <a class="code" href="ddh__multi_8h.html#a481a1414c1b36b588a81d9ce252d43c3">cfe_ddh_multi_ciphertext_init</a>(&amp;ct, &amp;encryptors[i]);</div><div class="line">    <a class="code" href="ddh__multi_8h.html#ad85e1b112a78b15de7274a6f4cea7e69">cfe_ddh_multi_encrypt</a>(&amp;ct, &amp;encryptors[i], x_vec, pub_key, otp);</div><div class="line">    <a class="code" href="mat_8h.html#a625c8025ba8b0863914bd4da4dd99355">cfe_mat_set_vec</a>(&amp;ciphertext, &amp;ct, i);</div><div class="line">    <a class="code" href="vec_8h.html#a672d016c769ce3ba57b126eaf6fca4ad">cfe_vec_free</a>(&amp;ct);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Ciphers are collected by decryptor, who then computes</span></div><div class="line"><span class="comment">// inner product over vectors from all encryptors.</span></div><div class="line"><a class="code" href="ddh__multi_8h.html#a8a04d0a87dd726b4d755da765f075b93">cfe_ddh_multi_copy</a>(&amp;decryptor, &amp;m);</div><div class="line"><a class="code" href="ddh__multi_8h.html#a4e9443b0871bcf729c8da5cba1adf515">cfe_ddh_multi_decrypt</a>(prod, &amp;decryptor, &amp;ciphertext, &amp;fe_key, &amp;Y);</div></div><!-- fragment --><p> Note that above we instantiate multiple encryptors - in reality, different encryptors will be instantiated on different machines. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
